#!/usr/bin/env bash

########################################################################################

# Utility name
APP="WEBKAOS Utils"

# Utility version
VER="1.3.3"

########################################################################################

NORM=0
BOLD=1
UNLN=4
RED=31
GREEN=32
YELLOW=33
BLUE=34
MAG=35
CYAN=36
GREY=37
DARK=90

CL_NORM="\e[${NORM}m"
CL_RED="\e[0;${RED};49m"
CL_GREEN="\e[0;${GREEN};49m"
CL_YELLOW="\e[0;${YELLOW};49m"
CL_BLUE="\e[0;${BLUE};49m"
CL_MAG="\e[0;${MAG};49m"
CL_CYAN="\e[0;${CYAN};49m"
CL_GREY="\e[0;${GREY};49m"
CL_DARK="\e[0;${DARK};49m"
CL_BL_RED="\e[1;${RED};49m"
CL_BL_GREEN="\e[1;${GREEN};49m"
CL_BL_YELLOW="\e[1;${YELLOW};49m"
CL_BL_BLUE="\e[1;${BLUE};49m"
CL_BL_MAG="\e[1;${MAG};49m"
CL_BL_CYAN="\e[1;${CYAN};49m"
CL_BL_GREY="\e[1;${GREY};49m"
CL_BL_DARK="\e[1;${DARK};49m"

########################################################################################

# Pattern used for generating temporary files and directories
TMP_PATTERN="/tmp/_wu.XXXXXXXXX"

########################################################################################

SUPPORTED_ARGS="!help !usage !version !ver !no_colors"
SHORT_ARGS="h:!help v:!version nc:!no_colors"

########################################################################################

# Main functions
#
# *: All arguments passed to script
#
# Code: No
# Echo: No
main() {
  if [[ ! -t 1 || -n "$no_colors" ]] ; then
    unset NORM BOLD UNLN RED GREEN YELLOW BLUE MAG CYAN GREY DARK
    unset CL_NORM CL_BOLD CL_UNLN CL_RED CL_GREEN CL_YELLOW CL_BLUE CL_MAG CL_CYAN CL_GREY CL_DARK
    unset CL_BL_RED CL_BL_GREEN CL_BL_YELLOW CL_BL_BLUE CL_BL_MAG CL_BL_CYAN CL_BL_GREY CL_BL_DARK
  fi

  if [[ $version || $ver ]] ; then
    about && exit 0
  fi

  if [[ $# -eq 0 || $help || $usage ]] ; then
    usage && exit 0
  fi

  local cmd="$1"

  shift 1

  case $cmd in
    "csr-gen")    genCSR "$@"        ;;
    "hpkp-gen")   genHPKPHeader "$@" ;;
    "ocsp-gen")   genOCSP "$@"       ;;
    "ocsp-check") checkOCSP "$@"     ;;
    *) error "Unknown command ${CL_BL_RED}${cmd}" $RED
       doExit 1 ;;
  esac

  doExit 0
}

# Generate OCSP
#
# 1: Server cert or cert chain file (String)
# 2: Issuer cert (String) [Optional]
#
# Code: No
# Echo: No
genOCSP() {
  local issuer_cert server_cert output

  if [[ $# -eq 0 ]] ; then
    usage && doExit 0
  fi

  if [[ ! -f $1 ]] ; then
    error "File ${CL_BL_RED}${1}${CL_RED} does not exist" $RED
    return 1
  fi

  if isChain "$1" ; then
    server_cert=$(extractCertFromChain "$1" 1)
    issuer_cert=$(extractCertFromChain "$1" 2)
    output=$(echo "$1" | sed 's/-chain//' | sed 's/.crt/.ocsp/')
  else
    server_cert="$1"
    issuer_cert="$2"
    output=$(echo "$1" | sed 's/.crt/.ocsp/')
  fi

  if [[ ! -f $server_cert ]] ; then
    error "Server certificate file ${CL_BL_RED}${server_cert}${CL_RED} is not exist" $RED
    doExit 1
  fi

  if [[ ! -f $issuer_cert ]] ; then
    error "Issuer certificate file ${CL_BL_RED}${issuer_cert}${CL_RED} is not exist" $RED
    doExit 1
  fi

  generateOCSPFile "$issuer_cert" "$server_cert" "$output"

  if [[ $? -ne 0 ]] ; then
    doExit 1
  fi
}

# Check OCSP stapling
#
# 1: Host and port (String)
#
# Code: No
# Echo: No
checkOCSP() {
  if [[ $# -eq 0 ]] ; then
    usage && exit 0
  fi

  local host server_name tmp_file status

  host="$1"
  server_name="${2:-$host}"
  tmp_file=$(mktemp -u "$TMP_PATTERN")
  status=$(openssl s_client -servername "$server_name" -connect "$host:443" -tls1 -tlsextdebug -status 2>&1 < /dev/null &> "$tmp_file")

  if [[ $(grep 'OCSP Response Status: successful' "$tmp_file") == "" ]] ; then
    error "OCSP Response Status: ${CL_RED}No response sent${CL_NORM}"
    doExit 1
  fi

  show "OCSP Response Status: ${CL_GREEN}Success${CL_NORM}"
  grep -A 14 'OCSP Response Data:' "$tmp_file"
}

# Generate signing request
#
# 1: Hostname (String)
#
# Code: No
# Echo: No
genCSR() {
  if [[ $# -eq 0 ]] ; then
    usage && doExit 0
  fi

  local host="$1"

  openssl req -new -newkey rsa:4096 -nodes -sha256 -keyout "${host}.key" -out "${host}.csr"
}

# Generate HPKP for some request
#
# 1: Path to csr file (String)
#
genHPKPHeader() {
  if [[ $# -eq 0 ]] ; then
    usage && doExit 0
  fi

  local main_file backup_file main_pin backup_pin

  main_file="$1"
  backup_file="$2"

  if [[ ! -r $main_file ]] ; then
    error "File ${CL_BL_RED}${main_file}${CL_RED} is not readable" $RED
    doExit 1
  fi

  main_pin=$(generateHPKHHash "$main_file")

  if [[ -n "$backup_file" ]] ; then
    backup_pin=$(generateHPKHHash "$backup_file")
  fi

  if [[ -z "$main_pin" ]] ; then
    error "Can't generate HPKP for given request" $RED
    doExit 1
  fi

  show "\n${CL_BL_GREEN}HPKP Header successfully generated!${CL_GREEN} Add this header as part of your config file.${CL_NORM}"

  if [[ -z "$backup_pin" ]] ; then
    show "\nadd_header Public-Key-Pins 'pin-sha256=\"$main_pin\";max-age=86400';\n"
  else
    show "\nadd_header Public-Key-Pins 'pin-sha256=\"$main_pin\";pin-sha256=\"$backup_pin\";max-age=86400';\n"
  fi

  show "More info: https://developer.mozilla.org/en-US/docs/Web/Security/Public_Key_Pinning\n" $DARK
}

########################################################################################

# Generate OCSP file
#
# 1: Path to server certificate (String)
# 2: Path to issuer certificate (String)
# 3: Output name (String) [Optional]
#
# Code: Yes
# Echo: No
generateOCSPFile() {
  local issuer_cert server_cert output url

  issuer_cert="$1"
  server_cert="$2"
  output="$3"

  url=$(openssl x509 -in "$server_cert" -text | grep "OCSP - URI:" | cut -d: -f2,3)

  openssl ocsp -noverify -no_nonce -respout "$output" -issuer "$issuer_cert" -cert "$server_cert" -url "$url" &> /dev/null

  if [[ $? -ne 0 ]] ; then
    error "Error while OCSP stapling file generation" $RED
    return 1
  fi

  show "OCSP stapling file saved as $output" $GREEN

  return 0
}

# Generate HPKP hash from given file
#
# 1: Key / CRT / CSR file
#
# Code: No
# Echo: Hash (String)
generateHPKHHash() {
  local file="$1"

  if [[ "$file" == *.key ]] ; then
    openssl rsa -in "$file" -outform der -pubout 2>/dev/null | openssl dgst -sha256 -binary | openssl enc -base64
  elif [[ "$file" == *.csr ]] ; then
    openssl req -in "$file" -pubkey -noout 2>/dev/null | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -binary | openssl enc -base64
  elif [[ "$file" == *.crt ]] ; then
    openssl x509 -in "$file" -pubkey -noout 2>/dev/null | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -binary | openssl enc -base64
  else
    echo ""
  fi
}

# Check if given file is chain
#
# 1: Path to file (String)
#
# Code: Yes
# Echo: No
isChain() {
  local file="$1"

  [[ ! -f $file ]] && return 1

  if [[ $(grep -c "BEGIN CERTIFICATE" "$file") -le 1 ]] ; then
    return 1
  fi

  return 0
}

# Extract certificate from chain to file
#
# 1: Path to chain file (String)
# 2: Number of certificate in chain (Number)
#
# Code: No
# Echo: Path to temporary file with certificate (String)
extractCertFromChain() {
  local chain cert_num cert_start cert_end tmp_file

  chain="$1"
  cert_num="$2"

  cert_start=$(grep -n "BEGIN CERTIFICATE" "$chain" | cut -f1 -d: | sed -n "${cert_num}p")
  cert_end=$(grep -n "END CERTIFICATE" "$chain" | cut -f1 -d: | sed -n "${cert_num}p")

  if [[ -z "$cert_start" || -z "$cert_end" ]] ; then
    return
  fi

  tmp_file=$(mktemp -u $TMP_PATTERN)

  cat "$chain" | sed -n "${cert_start},${cert_end}p" > "$tmp_file"

  echo "$tmp_file"
}

# Remove temporary data and exit with given exit code
#
# 1: Exit code (Number) [Optional]
#
# Code: No
# Echo: No
doExit() {
  local ec="${1:-0}"

  rm -f "${TMP_PATTERN//XXXXXXXXX/}*"

  exit "$ec"
}

########################################################################################

# Show message
#
# 1: Message (String)
# 2: Message color (Number) [Optional]
#
# Code: No
# Echo: No
show() {
  if [[ -n "$2" && -z "$no_colors" ]] ; then
    echo -e "\e[${2}m${1}\e[0m"
  else
    echo -e "$*"
  fi
}

# Print error message
#
# 1: Message (String)
# 2: Message color (Number) [Optional]
#
# Code: No
# Echo: No
error() {
  show "$@" 1>&2
}

# Print usage info
#
# Code: No
# Echo: No
usage() {
  show ""
  show "${CL_BOLD}Usage:${CL_NORM} webkaos-utils ${CL_YELLOW}command${CL_NORM} args..."
  show ""
  show "Commands" $BOLD
  show ""

  if [[ -n "$DARK" ]] ; then
    show "  ${CL_YELLOW}csr-gen${CL_NORM} ${CL_GREY}host${CL_NORM} ${CL_DARK}......................${CL_NORM} Generate RSA key and a certificate signing request"
    show "${CL_DARK}┌ ${CL_YELLOW}hpkp-gen${CL_NORM} ${CL_GREY}csr backup${CL_NORM} ${CL_DARK}...............${CL_NORM} Generate HTTP public key pinning (HPKP) header from CSR file"
    show "${CL_DARK}│ ${CL_YELLOW}hpkp-gen${CL_NORM} ${CL_GREY}key backup${CL_NORM} ${CL_DARK}...............${CL_NORM} Generate HTTP public key pinning (HPKP) header from KEY file"
    show "${CL_DARK}└ ${CL_YELLOW}hpkp-gen${CL_NORM} ${CL_GREY}crt backup${CL_NORM} ${CL_DARK}...............${CL_NORM} Generate HTTP public key pinning (HPKP) header from CRT file"
    show "${CL_DARK}┌ ${CL_YELLOW}ocsp-gen${CL_NORM} ${CL_GREY}server-cert${CL_NORM} ${CL_GREY}issuer-cert${CL_NORM} ${CL_DARK}..${CL_NORM} Generate OCSP stapling file from server certificate"
    show "${CL_DARK}└ ${CL_YELLOW}ocsp-gen${CL_NORM} ${CL_GREY}cert-chain${CL_NORM} ${CL_DARK}...............${CL_NORM} Generate OCSP stapling file from server certificate chain"
    show "  ${CL_YELLOW}ocsp-check${CL_NORM} ${CL_GREY}host${CL_NORM} ${CL_DARK}...................${CL_NORM} Check OCSP response status for some host"
  else
    show "  csr-gen host                        Generate RSA key and a certificate signing request"
    show "┌ hpkp-gen csr backup                 Generate HTTP public key pinning (HPKP) header from CSR file"
    show "│ hpkp-gen key backup                 Generate HTTP public key pinning (HPKP) header from KEY file"
    show "└ hpkp-gen crt backup                 Generate HTTP public key pinning (HPKP) header from CRT file"
    show "┌ ocsp-gen server-cert issuer-cert    Generate OCSP stapling file from server certificate"
    show "└ ocsp-gen cert-chain                 Generate OCSP stapling file from server certificate chain"
    show "  ocsp-check host                     Check OCSP response status for some host"
  fi

  show ""
  show "Options" $BOLD
  show ""
  
  if [[ -n "$DARK" ]] ; then
    show "  ${CL_GREEN}--help, -h${CL_NORM} ${CL_DARK}.....${CL_NORM} Show this help message"
    show "  ${CL_GREEN}--version, -v${CL_NORM} ${CL_DARK}..${CL_NORM} Show information about version"
  else
    show "  --help, -h       Show this help message"
    show "  --version, -v    Show information about version"
  fi

  show ""
  show "Examples" $BOLD
  show ""
  show "  webkaos-utils csr-gen domain.com"
  show "  Generate RSA key and a certificate signing request for domain.com" $DARK
  show ""
  show "  webkaos-utils hpkp-gen domain.com.csr domain.com.backup.key"
  show "  Generate HTTP public key pinning (HPKP) header with server and backup pins" $DARK
  show ""
  show "  webkaos-utils ocsp-gen sever.crt issuer.crt"
  show "  Generate OCSP stapling file using server and issuer certificates" $DARK
  show ""
  show "  webkaos-utils ocsp-gen sever-chain.crt"
  show "  Generate OCSP stapling file using certificate chain" $DARK
  show ""
  show "  webkaos-utils ocsp-check essentialkaos.com"
  show "  Check OCSP response status for essentialkaos.com" $DARK
  show ""
}

# Show info about version
#
# Code: No
# Echo: No
about() {
  show ""
  show "${CL_BL_CYAN}$APP${CL_NORM} ${CL_CYAN}$VER${CL_NORM} - Helpers for working with webkaos server"
  show ""
  show "Copyright (C) 2009-$(date +%Y) ESSENTIAL KAOS" $DARK
  show "Essential Kaos Open Source License <https://essentialkaos.com/ekol>" $DARK
  show ""
}

# Show warning message about unsupported argument
#
# 1: Argument name (String)
#
# Code: No
# Echo: No
showArgWarn() {
  error "Unknown argument $1" $RED
  exit 1
}

## ARGUMENTS PARSING 3 #################################################################

[[ $# -eq 0 ]] && main && exit $?

unset arg argn argm argv argt argk

argv="$*" ; argt=""

while [[ -n "$1" ]] ; do
  if [[ "$1" =~ \  && -n "$argn" ]] ; then
    declare "$argn=$1"

    unset argn && shift && continue
  elif [[ $1 =~ ^-{1}[a-zA-Z0-9]{1,2}+.*$ ]] ; then
    argm=${1:1}

    if [[ \ $SHORT_ARGS\  =~ \ $argm:!?([a-zA-Z0-9_]*) ]] ; then
      arg="${BASH_REMATCH[1]}"
    else
      declare -F showArgWarn &>/dev/null && showArgWarn "-$argm"
      shift && continue
    fi

    if [[ -z "$argn" ]] ; then
      argn=$arg
    else
      [[ -z "$argk" ]] && ( declare -F showArgValWarn &>/dev/null && showArgValWarn "--$argn" ) || declare "$argn=true"
      argn=$arg
    fi

    if [[ ! $SUPPORTED_ARGS\  =~ !?$argn\  ]] ; then
      declare -F showArgWarn &>/dev/null && showArgWarn "-$argm"
      shift && continue
    fi

    if [[ ${BASH_REMATCH[0]:0:1} == "!" ]] ; then
      declare "$argn=true" ; unset argn ; argk=true
    else
      unset argk
    fi

    shift && continue
  elif [[ "$1" =~ ^-{2}[a-zA-Z]{1}[a-zA-Z0-9_-]+.*$ ]] ; then
    arg=${1:2}

    if [[ $arg == *=* ]] ; then
      IFS="=" read -ra arg <<< "$arg"

      argm="${arg[0]}" ; argm=${argm//-/_}

      if [[ ! $SUPPORTED_ARGS\  =~ $argm\  ]] ; then
        declare -F showArgWarn &>/dev/null && showArgWarn "--${arg[0]//_/-}"
        shift && continue
      fi

      [[ -n "${!argm}" && $MERGEABLE_ARGS\  =~ $argm\  ]] && declare "$argm=${!argm} ${arg[@]:1:99}" || declare "$argm=${arg[@]:1:99}"

      unset argm && shift && continue
    else
      arg=${arg//-/_}

      if [[ -z "$argn" ]] ; then
        argn=$arg
      else
        [[ -z "$argk" ]] && ( declare -F showArgValWarn &>/dev/null && showArgValWarn "--$argn" ) || declare "$argn=true"
        argn=$arg
      fi

      if [[ ! $SUPPORTED_ARGS\  =~ !?$argn\  ]] ; then
        declare -F showArgWarn &>/dev/null && showArgWarn "--${argn//_/-}"
        shift && continue
      fi

      if [[ ${BASH_REMATCH[0]:0:1} == "!" ]] ; then
        declare "$argn=true" ; unset argn ; argk=true
      else
        unset argk
      fi

      shift && continue
    fi
  else
    if [[ -n "$argn" ]] ; then
      [[ -n "${!argn}" && $MERGEABLE_ARGS\  =~ $argn\  ]] && declare "$argn=${!argn} $1" || declare "$argn=$1"

      unset argn && shift && continue
    fi
  fi

  argt="$argt $1" ; shift

done

[[ -n "$argn" ]] && declare "$argn=true"

unset arg argn argm argk

[[ -n "$KEEP_ARGS" ]] && main $argv || main ${argt:1:9999}

########################################################################################
